<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Chladni 3D ‚Äî Plate deformation</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body {
    margin:0;
    background:#0a0a0a;
    overflow:hidden;
    color:#eee;
    font-family: "Segoe UI", Roboto, sans-serif;
  }

  #controls {
    position:fixed;
    left:20px;
    top:20px;
    z-index:20;
    display:flex;
    flex-direction: column;
    gap:12px;
    padding:14px;
    background: rgba(20,20,20,0.8);
    backdrop-filter: blur(6px);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px;
    box-shadow: 0 8px 20px rgba(0,0,0,0.6);
  }

  #controls button {
    padding:8px 12px;
    border:none;
    border-radius:8px;
    background:#333;
    color:#fff;
    cursor:pointer;
    font-size:13px;
  }
  #controls button:hover{ background:#444; }

  #fileInput { background:#222; color:#ddd; padding:6px; border-radius:6px; }

  #seekSlider { width:180px; }

  #three {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 78vmin;
    height: 78vmin;
    transform: translate(-50%, -50%);
    border-radius: 14px;
    overflow: hidden;
    box-shadow:
      0 0 40px rgba(0,255,200,0.12),
      0 0 80px rgba(0,255,200,0.04);
    background: #000;
  }

  .label { font-size:12px; opacity:0.9; margin-bottom:4px; }
</style>


</head>
<body>

<div id="controls">
  <div>
    <input id="fileInput" type="file" accept="audio/*">
    <button id="micButton">üé§ Mic</button>
  </div>

  <div>
    <button id="playBtn">‚ñ∂ Play</button>
    <button id="pauseBtn">‚è∏ Pause</button>
    <button id="testBtn">üß™ Test</button>
  </div>

  <div class="label">Seek</div>
  <input id="seekSlider" type="range" min="0" max="1" step="0.001" value="0">

  <div class="label">Mode scale</div>
  <input id="scaleSlider" type="range" min="0" max="1" step="0.01" value="0.35">
</div>

<div id="three"></div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

/* ------------------ Basic Three.js Scene ------------------ */
const container = document.getElementById('three');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.01, 100);
camera.position.set(0, 1.8, 2.2);
camera.up.set(0,1,0);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 0.6;
controls.maxDistance = 6;
controls.target.set(0,0,0);

/* Lights */
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(3,4,1);
scene.add(dir);
const amb = new THREE.AmbientLight(0x666666, 0.7);
scene.add(amb);

/* ------------------ Plate mesh (plane) ------------------ */
/* resolution: segments per side. Higher -> nicer but heavier */
let SEG = 180; // ajusta si necesitas m√°s/menos detalle
const size = 1.8; // physical size of plane
let planeGeo = new THREE.PlaneGeometry(size, size, SEG, SEG);
planeGeo.rotateX(-Math.PI/2); // put xy plane to horizontal (x,z) with y up

// Color attribute for vertexColors
const colors = new Float32Array( (SEG+1)*(SEG+1) * 3 );
for(let i=0;i<colors.length;i++) colors[i] = 0.0;
planeGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

/* material with vertexColors and slightly metallic look */
const mat = new THREE.MeshStandardMaterial({
  vertexColors: true,
  side: THREE.DoubleSide,
  metalness: 0.1,
  roughness: 0.45,
  flatShading: false
});

const plate = new THREE.Mesh(planeGeo, mat);
plate.position.y = 0;
scene.add(plate);

/* Floor/grid faint */
const grid = new THREE.GridHelper(4, 20, 0x0a5c57, 0x052f2b);
grid.position.y = -0.001;
scene.add(grid);

/* ------------------ Modes setup (same logic que tu shader) ------------------ */
const nm = [];
for (let s=2; nm.length<32; s++){
  for(let n=1;n<s && nm.length<32;n++){ nm.push([n, s-n]); }
}
// nm now array of [n,m] pairs. We'll use first 16 modes to match tu l√≥gica
const NMODES = 16;

/* ------------------ Audio (copiado/adaptado) ------------------ */
let audioCtx = null, analyser = null, source = null, spectrum = null;
let audioBuffer = null;
let startTime = 0, startOffset = 0;
const fftSize = 4096;
let isTestMode = false, isPaused = false;

function ensureAudio(){
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = fftSize;
    analyser.smoothingTimeConstant = 0.6;
    spectrum = new Uint8Array(analyser.frequencyBinCount);
  }
  if (audioCtx.state === "suspended") audioCtx.resume();
}

/* UI references */
const fileInput = document.getElementById('fileInput');
const micButton = document.getElementById('micButton');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const testBtn = document.getElementById('testBtn');
const seekSlider = document.getElementById('seekSlider');
const scaleSlider = document.getElementById('scaleSlider');

fileInput.addEventListener('change', async (ev)=>{
  ensureAudio();
  isTestMode = false;
  if (source && source.disconnect) try { source.disconnect(); } catch(e){}
  const file = ev.target.files[0];
  if (!file) return;
  const arr = await file.arrayBuffer();
  audioBuffer = await audioCtx.decodeAudioData(arr);
  playFrom(0);
});

micButton.addEventListener('click', async ()=>{
  ensureAudio();
  isTestMode = false;
  if (source && source.disconnect) try { source.disconnect(); } catch(e){}
  const stream = await navigator.mediaDevices.getUserMedia({audio:true});
  source = audioCtx.createMediaStreamSource(stream);
  source.connect(analyser);
  analyser.connect(audioCtx.destination);
});

function playFrom(sec){
  if (!audioBuffer) return;
  if (source && source.stop) try { source.stop(); } catch(e){}
  source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(analyser);
  analyser.connect(audioCtx.destination);
  startTime = audioCtx.currentTime;
  startOffset = sec;
  source.start(0, sec);
}

playBtn.onclick = ()=>{
  isPaused = false;
  if (audioCtx) audioCtx.resume();
};

pauseBtn.onclick = ()=>{
  isPaused = true;
  if (audioCtx) audioCtx.suspend();
};

testBtn.onclick = ()=> isTestMode = true;

/* seekbar */
let isSeeking = false;
seekSlider.oninput = ()=>{
  if (!audioBuffer) return;
  isSeeking = true;
  const pos = seekSlider.value * audioBuffer.duration;
  playFrom(pos);
  setTimeout(()=> isSeeking = false, 200);
};

function updateSeekBar(){
  if (!audioBuffer || !source || isSeeking) return;
  const current = (audioCtx.currentTime - startTime) + startOffset;
  const normalized = Math.min(current / audioBuffer.duration, 1);
  seekSlider.value = normalized;
}

/* ------------------ Mode amplitudes (array of 16 floats) ------------------ */
let modeAmps = new Float32Array(NMODES);

function computeAmps(time){
  if (isTestMode){
    for(let i=0;i<NMODES;i++){
      modeAmps[i] = 0.05 + 0.95 * Math.abs( Math.sin(time*0.00035 + i*0.6) );
    }
  } else if (!isPaused && analyser){
    analyser.getByteFrequencyData(spectrum);
    for (let i=0;i<NMODES;i++){
      const t = (i+1)/NMODES;
      // same frequency mapping as tu shader
      const freq = 80 * Math.pow(20000/20, t);
      const bin = Math.round(freq / (audioCtx.sampleRate / analyser.fftSize));
      let sum = 0, count=0;
      for(let k=-6;k<=6;k++){
        const idx = Math.min(Math.max(0, bin+k), spectrum.length-1);
        sum += spectrum[idx]; count++;
      }
      const avg = sum / (count * 255.0);
      modeAmps[i] = Math.min(avg * 3.0, 1.0);
    }
  } else {
    for(let i=0;i<NMODES;i++) modeAmps[i] = 0;
  }
}

/* ------------------ Deform function: update vertex positions ------------------ */
/* We'll interpret plane vertices in local X,Z in [-size/2, size/2] */
const posAttr = planeGeo.getAttribute('position');
const basePositions = new Float32Array(posAttr.array); // copy original positions
const vertexCount = posAttr.count;
const colorAttr = planeGeo.getAttribute('color');
function deformPlane(scale){
  const offsetX = 0.5;
  const offsetY = 0.5;

  for(let i=0;i<vertexCount;i++){
    const ix = i*3;
    const x = basePositions[ix + 0];
    const z = basePositions[ix + 2];

    // map [-size/2,size/2] ‚Üí [0,1]
    const uvx = x / size + 0.5;
    const uvy = z / size + 0.5;

    // EXACT MATCH WITH SHADER:
    // p = (uv - 0.5) * 2.5 + offset
    const px = (uvx - 0.5) * 2.5 + offsetX;
    const py = (uvy - 0.5) * 2.5 + offsetY;

    let sum = 0.0;
    for(let m=0;m<NMODES;m++){
      const A = modeAmps[m];
      const [n, mm] = nm[m];

      sum += A *
             Math.sin(n * Math.PI * (px + 0.5)) *
             Math.sin(mm * Math.PI * (py + 0.5));
    }

    // height = sum EXACTO (nada de potencias ni sign)
    const height = sum * scale;

    posAttr.array[ix + 1] = height;

    // color nodal EXACTO igual al shader:
    const v = Math.abs(sum);
    const vv = v*v;
    const line = 1.0 - smoothstep(0.03,0.06,vv);

    const cidx = i*3;
    const col = line; // brillo m√≠nimo
    colorAttr.array[cidx+0] = col * 0.05;
    colorAttr.array[cidx+1] = col * 0.85;
    colorAttr.array[cidx+2] = col * 0.65;
  }

  posAttr.needsUpdate = true;
  colorAttr.needsUpdate = true;
  planeGeo.computeVertexNormals();
}

function smoothstep(edge0, edge1, x){
  const t = Math.min(Math.max((x - edge0) / (edge1 - edge0), 0), 1);
  return t * t * (3 - 2 * t);
}
/* ------------------ Animation loop ------------------ */
let last = performance.now();
function animate(time){
  requestAnimationFrame(animate);
  const dt = time - last;
  last = time;

  computeAmps(time);

  const scale = parseFloat(scaleSlider.value) || 0.35;
  deformPlane(scale * 0.8); // global scale

  controls.update();
  renderer.render(scene, camera);

  updateSeekBar();
}
animate(performance.now());

/* ------------------ Handle resize ------------------ */
function onResize(){
  const w = container.clientWidth;
  const h = container.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', onResize);

/* ------------------ Initialize default test mode so something moves */
isTestMode = true;

</script>
</body>
</html>
